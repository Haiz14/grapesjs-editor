{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/grapesjs-touch@0.1.1/node_modules/grapesjs-touch/dist/webpack:/grapesjs-touch/webpack/universalModuleDefinition", "../../node_modules/.pnpm/grapesjs-touch@0.1.1/node_modules/grapesjs-touch/dist/webpack:/grapesjs-touch/webpack/bootstrap", "../../node_modules/.pnpm/grapesjs-touch@0.1.1/node_modules/grapesjs-touch/dist/webpack:/grapesjs-touch/src/index.js", "../../node_modules/.pnpm/grapesjs-touch@0.1.1/node_modules/grapesjs-touch/dist/webpack:/grapesjs-touch/src/DragDropTouch.js", "../../node_modules/.pnpm/grapesjs-touch@0.1.1/node_modules/grapesjs-touch/dist/webpack:/grapesjs-touch/src/touchpolyfill.js"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"grapesjs-touch\"] = factory();\n\telse\n\t\troot[\"grapesjs-touch\"] = factory();\n})(window, function() {\nreturn ", " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n", "import DragDropTouch from './DragDropTouch';\nimport touchpolyfill from './touchpolyfill';\n\nexport default editor => {\n  touchpolyfill();\n  DragDropTouch();\n};\n", "// https://github.com/Bernardo-Castilho/dragdroptouch/blob/master/DragDropTouch.js\n\nexport default () => {\n  var DragDropTouch;\n  (function(DragDropTouch_1) {\n    'use strict';\n    /**\n     * Object used to hold the data that is being dragged during drag and drop operations.\n     *\n     * It may hold one or more data items of different types. For more information about\n     * drag and drop operations and data transfer objects, see\n     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer\">HTML Drag and Drop API</a>.\n     *\n     * This object is created automatically by the @see:DragDropTouch singleton and is\n     * accessible through the @see:dataTransfer property of all drag events.\n     */\n    var DataTransfer = (function() {\n      function DataTransfer() {\n        this._dropEffect = 'move';\n        this._effectAllowed = 'all';\n        this._data = {};\n      }\n      Object.defineProperty(DataTransfer.prototype, 'dropEffect', {\n        /**\n         * Gets or sets the type of drag-and-drop operation currently selected.\n         * The value must be 'none',  'copy',  'link', or 'move'.\n         */\n        get: function() {\n          return this._dropEffect;\n        },\n        set: function(value) {\n          this._dropEffect = value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(DataTransfer.prototype, 'effectAllowed', {\n        /**\n         * Gets or sets the types of operations that are possible.\n         * Must be one of 'none', 'copy', 'copyLink', 'copyMove', 'link',\n         * 'linkMove', 'move', 'all' or 'uninitialized'.\n         */\n        get: function() {\n          return this._effectAllowed;\n        },\n        set: function(value) {\n          this._effectAllowed = value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(DataTransfer.prototype, 'types', {\n        /**\n         * Gets an array of strings giving the formats that were set in the @see:dragstart event.\n         */\n        get: function() {\n          return Object.keys(this._data);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      /**\n       * Removes the data associated with a given type.\n       *\n       * The type argument is optional. If the type is empty or not specified, the data\n       * associated with all types is removed. If data for the specified type does not exist,\n       * or the data transfer contains no data, this method will have no effect.\n       *\n       * @param type Type of data to remove.\n       */\n      DataTransfer.prototype.clearData = function(type) {\n        if (type != null) {\n          delete this._data[type];\n        } else {\n          this._data = null;\n        }\n      };\n      /**\n       * Retrieves the data for a given type, or an empty string if data for that type does\n       * not exist or the data transfer contains no data.\n       *\n       * @param type Type of data to retrieve.\n       */\n      DataTransfer.prototype.getData = function(type) {\n        return this._data[type] || '';\n      };\n      /**\n       * Set the data for a given type.\n       *\n       * For a list of recommended drag types, please see\n       * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Recommended_Drag_Types.\n       *\n       * @param type Type of data to add.\n       * @param value Data to add.\n       */\n      DataTransfer.prototype.setData = function(type, value) {\n        this._data[type] = value;\n      };\n      /**\n       * Set the image to be used for dragging if a custom one is desired.\n       *\n       * @param img An image element to use as the drag feedback image.\n       * @param offsetX The horizontal offset within the image.\n       * @param offsetY The vertical offset within the image.\n       */\n      DataTransfer.prototype.setDragImage = function(img, offsetX, offsetY) {\n        var ddt = DragDropTouch._instance;\n        ddt._imgCustom = img;\n        ddt._imgOffset = { x: offsetX, y: offsetY };\n      };\n      return DataTransfer;\n    })();\n    DragDropTouch_1.DataTransfer = DataTransfer;\n    /**\n     * Defines a class that adds support for touch-based HTML5 drag/drop operations.\n     *\n     * The @see:DragDropTouch class listens to touch events and raises the\n     * appropriate HTML5 drag/drop events as if the events had been caused\n     * by mouse actions.\n     *\n     * The purpose of this class is to enable using existing, standard HTML5\n     * drag/drop code on mobile devices running IOS or Android.\n     *\n     * To use, include the DragDropTouch.js file on the page. The class will\n     * automatically start monitoring touch events and will raise the HTML5\n     * drag drop events (dragstart, dragenter, dragleave, drop, dragend) which\n     * should be handled by the application.\n     *\n     * For details and examples on HTML drag and drop, see\n     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Drag_operations.\n     */\n    var DragDropTouch = (function() {\n      /**\n       * Initializes the single instance of the @see:DragDropTouch class.\n       */\n      function DragDropTouch() {\n        this._lastClick = 0;\n        // enforce singleton pattern\n        if (DragDropTouch._instance) {\n          throw 'DragDropTouch instance already created.';\n        }\n        // detect passive event support\n        // https://github.com/Modernizr/Modernizr/issues/1894\n        var supportsPassive = false;\n        document.addEventListener('test', function() {}, {\n          get passive() {\n            supportsPassive = true;\n            return true;\n          }\n        });\n        // listen to touch events\n        if ('ontouchstart' in document) {\n          var d = document,\n            ts = this._touchstart.bind(this),\n            tm = this._touchmove.bind(this),\n            te = this._touchend.bind(this),\n            opt = supportsPassive ? { passive: false, capture: false } : false;\n          d.addEventListener('touchstart', ts, opt);\n          d.addEventListener('touchmove', tm, opt);\n          d.addEventListener('touchend', te);\n          d.addEventListener('touchcancel', te);\n        }\n      }\n      /**\n       * Gets a reference to the @see:DragDropTouch singleton.\n       */\n      DragDropTouch.getInstance = function() {\n        return DragDropTouch._instance;\n      };\n      // ** event handlers\n      DragDropTouch.prototype._touchstart = function(e) {\n        var _this = this;\n        if (this._shouldHandle(e)) {\n          // raise double-click and prevent zooming\n          if (Date.now() - this._lastClick < DragDropTouch._DBLCLICK) {\n            if (this._dispatchEvent(e, 'dblclick', e.target)) {\n              e.preventDefault();\n              this._reset();\n              return;\n            }\n          }\n          // clear all variables\n          this._reset();\n          // get nearest draggable element\n          var src = this._closestDraggable(e.target);\n          if (src) {\n            // give caller a chance to handle the hover/move events\n            if (\n              !this._dispatchEvent(e, 'mousemove', e.target) &&\n              !this._dispatchEvent(e, 'mousedown', e.target)\n            ) {\n              // get ready to start dragging\n              this._dragSource = src;\n              this._ptDown = this._getPoint(e);\n              this._lastTouch = e;\n              e.preventDefault();\n              // show context menu if the user hasn't started dragging after a while\n              setTimeout(function() {\n                if (_this._dragSource == src && _this._img == null) {\n                  if (_this._dispatchEvent(e, 'contextmenu', src)) {\n                    _this._reset();\n                  }\n                }\n              }, DragDropTouch._CTXMENU);\n            }\n          }\n        }\n      };\n      DragDropTouch.prototype._touchmove = function(e) {\n        if (this._shouldHandle(e)) {\n          var target = this._getTarget(e);\n          // start dragging\n          if (this._dragSource && !this._img) {\n            var delta = this._getDelta(e);\n            if (delta > DragDropTouch._THRESHOLD) {\n              this._dispatchEvent(e, 'dragstart', this._dragSource);\n              this._createImage(e);\n              this._dispatchEvent(e, 'dragenter', target);\n            }\n          }\n          // continue dragging\n          if (this._img) {\n            this._lastTouch = e;\n            e.preventDefault(); // prevent scrolling\n            if (target != this._lastTarget) {\n              this._dispatchEvent(this._lastTouch, 'dragleave', this._lastTarget);\n              this._dispatchEvent(e, 'dragenter', target);\n              this._lastTarget = target;\n            }\n            this._moveImage(e);\n            this._dispatchEvent(e, 'dragover', target);\n          }\n          // see if target wants to handle move\n          if (this._dispatchEvent(e, 'mousemove', target)) {\n            this._lastTouch = e;\n            e.preventDefault();\n            return;\n          }\n        }\n      };\n      DragDropTouch.prototype._touchend = function(e) {\n        if (this._shouldHandle(e)) {\n          // finish dragging\n          this._destroyImage();\n          if (this._dragSource) {\n            if (e.type.indexOf('cancel') < 0) {\n              this._dispatchEvent(this._lastTouch, 'drop', this._lastTarget);\n            }\n            this._dispatchEvent(this._lastTouch, 'dragend', this._dragSource);\n            this._reset();\n            // prevent mouse up on drag\n            e.preventDefault();\n            return;\n          }\n          // see if target wants to handle up\n          if (this._dispatchEvent(this._lastTouch, 'mouseup', e.target)) {\n            e.preventDefault();\n            return;\n          }\n          // user clicked the element but didn't drag, so clear the source and simulate a click\n          if (!this._img) {\n            this._dragSource = null;\n            this._dispatchEvent(this._lastTouch, 'click', e.target);\n            this._lastClick = Date.now();\n          }\n        }\n      };\n      // ** utilities\n      // ignore events that have been handled or that involve more than one touch\n      DragDropTouch.prototype._shouldHandle = function(e) {\n        return e && !e.defaultPrevented && e.touches && e.touches.length < 2;\n      };\n      // clear all members\n      DragDropTouch.prototype._reset = function() {\n        this._destroyImage();\n        this._dragSource = null;\n        this._lastTouch = null;\n        this._lastTarget = null;\n        this._ptDown = null;\n        this._dataTransfer = new DataTransfer();\n      };\n      // get point for a touch event\n      DragDropTouch.prototype._getPoint = function(e, page) {\n        if (e && e.touches) {\n          e = e.touches[0];\n        }\n        return { x: page ? e.pageX : e.clientX, y: page ? e.pageY : e.clientY };\n      };\n      // get distance between the current touch event and the first one\n      DragDropTouch.prototype._getDelta = function(e) {\n        var p = this._getPoint(e);\n        return Math.abs(p.x - this._ptDown.x) + Math.abs(p.y - this._ptDown.y);\n      };\n      // get the element at a given touch event\n      DragDropTouch.prototype._getTarget = function(e) {\n        var pt = this._getPoint(e),\n          el = document.elementFromPoint(pt.x, pt.y);\n        // if target element is an iframe, try propagating event to child element\n        if (el && el.nodeName === 'IFRAME') {\n          try {\n            var iframeDocument = el.contentWindow.document;\n            // get iframe absolute offset\n            var iframeAbsoluteOffset = { x: 0, y: 0 };\n            do {\n              iframeAbsoluteOffset.x += el.offsetLeft || 0;\n              iframeAbsoluteOffset.y += el.offsetTop || 0;\n              el = el.offsetParent;\n            } while (el);\n            // remove iframe absolute offset from touch position\n            var x = pt.x - iframeAbsoluteOffset.x,\n              y = pt.y - iframeAbsoluteOffset.y;\n            // get element on that position from iframe document\n            el = iframeDocument.elementFromPoint(x, y);\n          } catch (e) {\n            // iframe origin don't allow access\n          }\n        }\n        while (el && getComputedStyle(el).pointerEvents == 'none') {\n          el = el.parentElement;\n        }\n        return el;\n      };\n      // create drag image from source element\n      DragDropTouch.prototype._createImage = function(e) {\n        // just in case...\n        if (this._img) {\n          this._destroyImage();\n        }\n        // create drag image from custom element or drag source\n        var src = this._imgCustom || this._dragSource;\n        this._img = src.cloneNode(true);\n        this._copyStyle(src, this._img);\n        this._img.style.top = this._img.style.left = '-9999px';\n        // if creating from drag source, apply offset and opacity\n        if (!this._imgCustom) {\n          var rc = src.getBoundingClientRect(),\n            pt = this._getPoint(e);\n          this._imgOffset = { x: pt.x - rc.left, y: pt.y - rc.top };\n          this._img.style.opacity = DragDropTouch._OPACITY.toString();\n        }\n        // add image to document\n        this._moveImage(e);\n        document.body.appendChild(this._img);\n      };\n      // dispose of drag image element\n      DragDropTouch.prototype._destroyImage = function() {\n        if (this._img && this._img.parentElement) {\n          this._img.parentElement.removeChild(this._img);\n        }\n        this._img = null;\n        this._imgCustom = null;\n      };\n      // move the drag image element\n      DragDropTouch.prototype._moveImage = function(e) {\n        var _this = this;\n        requestAnimationFrame(function() {\n          if (_this._img) {\n            var pt = _this._getPoint(e, true),\n              s = _this._img.style;\n            s.position = 'absolute';\n            s.pointerEvents = 'none';\n            s.zIndex = '999999';\n            s.left = Math.round(pt.x - _this._imgOffset.x) + 'px';\n            s.top = Math.round(pt.y - _this._imgOffset.y) + 'px';\n          }\n        });\n      };\n      // copy properties from an object to another\n      DragDropTouch.prototype._copyProps = function(dst, src, props) {\n        for (var i = 0; i < props.length; i++) {\n          var p = props[i];\n          dst[p] = src[p];\n        }\n      };\n      DragDropTouch.prototype._copyStyle = function(src, dst) {\n        // remove potentially troublesome attributes\n        DragDropTouch._rmvAtts.forEach(function(att) {\n          dst.removeAttribute(att);\n        });\n        // copy canvas content\n        if (src instanceof HTMLCanvasElement) {\n          var cSrc = src,\n            cDst = dst;\n          cDst.width = cSrc.width;\n          cDst.height = cSrc.height;\n          cDst.getContext('2d').drawImage(cSrc, 0, 0);\n        }\n        // copy style (without transitions)\n        var cs = getComputedStyle(src);\n        for (var i = 0; i < cs.length; i++) {\n          var key = cs[i];\n          if (key.indexOf('transition') < 0) {\n            dst.style[key] = cs[key];\n          }\n        }\n        dst.style.pointerEvents = 'none';\n        // and repeat for all children\n        for (var i = 0; i < src.children.length; i++) {\n          this._copyStyle(src.children[i], dst.children[i]);\n        }\n      };\n      DragDropTouch.prototype._dispatchEvent = function(e, type, target) {\n        if (e && target) {\n          var evt = document.createEvent('Event'),\n            t = e.touches ? e.touches[0] : e;\n          evt.initEvent(type, true, true);\n          evt.button = 0;\n          evt.which = evt.buttons = 1;\n          this._copyProps(evt, e, DragDropTouch._kbdProps);\n          this._copyProps(evt, t, DragDropTouch._ptProps);\n          evt.dataTransfer = this._dataTransfer;\n          target.dispatchEvent(evt);\n          return evt.defaultPrevented;\n        }\n        return false;\n      };\n      // gets an element's closest draggable ancestor\n      DragDropTouch.prototype._closestDraggable = function(e) {\n        for (; e; e = e.parentElement) {\n          if (e.hasAttribute('draggable') && e.draggable) {\n            return e;\n          }\n        }\n        return null;\n      };\n      return DragDropTouch;\n    })();\n    /*private*/ DragDropTouch._instance = new DragDropTouch(); // singleton\n    // constants\n    DragDropTouch._THRESHOLD = 5; // pixels to move before drag starts\n    DragDropTouch._OPACITY = 0.5; // drag image opacity\n    DragDropTouch._DBLCLICK = 500; // max ms between clicks in a double click\n    DragDropTouch._CTXMENU = 900; // ms to hold before raising 'contextmenu' event\n    // copy styles/attributes from drag source to drag image element\n    DragDropTouch._rmvAtts = 'id,class,style,draggable'.split(',');\n    // synthesize and dispatch an event\n    // returns true if the event has been handled (e.preventDefault == true)\n    DragDropTouch._kbdProps = 'altKey,ctrlKey,metaKey,shiftKey'.split(',');\n    DragDropTouch._ptProps = 'pageX,pageY,clientX,clientY,screenX,screenY'.split(\n      ','\n    );\n    DragDropTouch_1.DragDropTouch = DragDropTouch;\n  })(DragDropTouch || (DragDropTouch = {}));\n}\n", "// https://github.com/CamHenlin/TouchPolyfill\n// polyfill touch functionality on browsers that have pointer functionality (that piece of trash internet explorer)\n// this thing is mostly just a hack on handjs, but does the reverse\n// cameron henlin, cam.henlin@gmail.com\n\n// jslint directive\n/*jslint browser: true, unparam: true, nomen: true*/\n/*global HTMLBodyElement, HTMLDivElement, HTMLImageElement, HTMLUListElement, HTMLAnchorElement, HTMLLIElement, HTMLTableElement, HTMLSpanElement, HTMLCanvasElement, SVGElement*/\n\nexport default () => {\n  (function() {\n    // We should start using 'use strict' as soon as we can get rid of the implied globals.\n    // 'use strict';\n\n    // the timestamp of the last touch event processed.\n    // It is used to determine what touches should be in the changedTouches TouchList array.\n    var lastHwTimestamp = 0,\n      // whether or not to log events to console\n      logToConsole = false,\n      userAgent = navigator.userAgent,\n      supportedEventsNames = [\n        'touchstart',\n        'touchmove',\n        'touchend',\n        'touchcancel',\n        'touchleave'\n      ],\n      // commented out because not used\n      // upperCaseEventsNames = [\"TouchStart\", \"TouchMove\", \"TouchEnd\", \"TouchCancel\", \"TouchLeave\"],\n      previousTargets = {},\n      // wraps a W3C compliant implementation of the \"touches\" TouchList\n      touchesWrapper,\n      // wraps a W3C compliant implementation of the \"changedTouches\" TouchList\n      changedTouchesWrapper,\n      // wraps a W3C compliant implementation of the \"targetTouches\" TouchList\n      targetTouchesWrapper;\n\n    // a constructor for an object that wraps a W3C compliant TouchList.\n    function TouchListWrapper() {\n      var touchList = []; // an array of W3C compliant Touch objects.\n\n      // constructor for W3C compliant touch object\n      // http://www.w3.org/TR/touch-events/\n      function Touch(\n        identifier,\n        target,\n        screenX,\n        screenY,\n        clientX,\n        clientY,\n        pageX,\n        pageY\n      ) {\n        this.identifier = identifier;\n        this.target = target;\n        this.screenX = screenX;\n        this.screenY = screenY;\n        this.clientX = clientX;\n        this.clientY = clientY;\n        this.pageX = pageX;\n        this.pageY = pageY;\n      }\n\n      // Search the TouchList for a Touch with the given identifier.\n      // If it is found, return it.  Otherwise, return null;\n      function getTouch(identifier) {\n        var i;\n        for (i = 0; i < touchList.length; i += 1) {\n          if (touchList[i].identifier === identifier) {\n            return touchList[i];\n          }\n        }\n      }\n\n      // If this is a new touch, add it to the TouchList.\n      // If this is an existing touch, update it in the TouchList.\n      function addUpdateTouch(touch) {\n        var i;\n        for (i = 0; i < touchList.length; i += 1) {\n          if (touchList[i].identifier === touch.identifier) {\n            touchList[i] = touch;\n            return;\n          }\n        }\n        // If we finished the loop, then this is a new touch.\n        touchList.push(touch);\n      }\n\n      function removeTouch(identifier) {\n        var i;\n        for (i = 0; i < touchList.length; i += 1) {\n          if (touchList[i].identifier === identifier) {\n            touchList.splice(i, 1);\n          }\n        }\n      }\n\n      function clearTouches() {\n        // According to http://stackoverflow.com/questions/1232040/how-to-empty-an-array-in-javascript\n        // this is the fastest way to clear the array.\n        while (touchList.length > 0) {\n          touchList.pop();\n        }\n      }\n\n      // Return true if the current TouchList object contains a touch at the specified screenX, clientY.\n      // Returns false otherwise.\n      // This is used to differentiate touches that have moved from those that haven't.\n      function containsTouchAt(screenX, screenY) {\n        var i;\n\n        for (i = 0; i < touchList.length; i += 1) {\n          if (\n            touchList[i].screenX === screenX &&\n            touchList[i].screenY === screenY\n          ) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      // touchList is the actual W3C compliant TouchList object being emulated.\n      this.touchList = touchList;\n\n      this.Touch = Touch;\n      this.getTouch = getTouch;\n      this.addUpdateTouch = addUpdateTouch;\n      this.removeTouch = removeTouch;\n      this.clearTouches = clearTouches;\n      this.containsTouchAt = containsTouchAt;\n    }\n\n    function touchesAreAtSameSpot(touch0, touch1) {\n      return (\n        touch0.screenX === touch1.screenX && touch0.screenY === touch1.screenY\n      );\n    }\n\n    // polyfill custom event\n    function CustomEvent(event, params) {\n      var evt;\n      params = params || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      evt = document.createEvent('CustomEvent');\n      evt.initCustomEvent(\n        event,\n        params.bubbles,\n        params.cancelable,\n        params.detail\n      );\n      return evt;\n    }\n\n    function checkPreventDefault(node) {\n      while (node && !node.handJobjs_forcePreventDefault) {\n        node = node.parentNode;\n      }\n      return !!node || window.handJobjs_forcePreventDefault;\n    }\n\n    // Touch events\n    function generateTouchClonedEvent(\n      sourceEvent,\n      newName,\n      canBubble,\n      target,\n      relatedTarget\n    ) {\n      var evObj, oldTouch, oldTarget;\n\n      // Updates the targetTouches so that it contains the touches from the \"touches\" TouchList\n      // that have the same target as the touch that triggered this event.\n      function updateTargetTouches(thisTouchTarget, touchesTouchList) {\n        var i, touch;\n\n        targetTouchesWrapper.clearTouches();\n\n        for (i = 0; i < touchesTouchList.length; i++) {\n          touch = touchesTouchList[i];\n          if (touch.target.isSameNode(thisTouchTarget)) {\n            targetTouchesWrapper.addUpdateTouch(touch);\n          }\n        }\n      }\n\n      function touchHandler(event) {\n        var eventType, oldTouch, touch, touchEvent, isTouchChanged;\n\n        log('touch!');\n\n        if (event.type === 'pointerdown') {\n          eventType = 'touchstart';\n        } else if (event.type === 'pointermove') {\n          eventType = 'touchmove';\n        } else {\n          throw new Error(\n            'touchHandler received invalid event type: ' +\n              eventType +\n              '. Valid event types are pointerdown and pointermove'\n          );\n        }\n        log(eventType);\n\n        touch = new touchesWrapper.Touch(\n          event.pointerId,\n          event.type === 'pointerdown' ? event.target : oldTarget,\n          event.screenX,\n          event.screenY,\n          event.clientX,\n          event.clientY,\n          event.pageX,\n          event.pageY\n        );\n\n        // Remove, from changedTouches, any Touch that is no longer being touched, or is being touched\n        // in exactly the same place.\n        // In order to make sure that simultaneous touches don't kick each other off of the changedTouches array\n        // (because they are processed as different pointer events), skip this if the lastHwTimestamp hasn't increased.\n        if (event.hwTimestamp > lastHwTimestamp) {\n          (function() {\n            var i, changedTouchList, changedTouch, matchingTouch, identifier;\n            changedTouchList = changedTouchesWrapper.touchList;\n            for (i = 0; i < changedTouchList.length; i += 1) {\n              changedTouch = changedTouchList[i];\n              identifier = changedTouch.identifier;\n              matchingTouch = touchesWrapper.getTouch(identifier);\n\n              if (\n                !matchingTouch ||\n                touchesAreAtSameSpot(matchingTouch, changedTouch)\n              ) {\n                changedTouchesWrapper.removeTouch(identifier);\n              }\n            }\n          })();\n        }\n\n        log('generating touch cloned');\n\n        touchesWrapper.addUpdateTouch(touch);\n        changedTouchesWrapper.addUpdateTouch(touch);\n        updateTargetTouches(touch.target, touchesWrapper.touchList);\n\n        event.type = eventType;\n        touchEvent = new CustomEvent(eventType, {\n          bubbles: true,\n          cancelable: true\n        });\n\n        touchEvent.touches = touchesWrapper.touchList;\n        touchEvent.changedTouches = changedTouchesWrapper.touchList;\n        touchEvent.targetTouches = targetTouchesWrapper.touchList;\n        touchEvent.type = eventType;\n\n        // Awesomely, I figured out how to keep track of the touches in the \"Touches\" TouchList using an array.\n        // TODO: Do the same thing for the changedTouches and targetTouches properties of the TouchEvent.\n        // TODONE! changedTouches is implemented.\n        // TODONE! targetTouches is implemented.\n\n        // The other members of the TouchEvent are altKey, metaKey, ctrlKey, and shiftKey\n\n        return touchEvent;\n      }\n\n      function touchChangedHandler(event) {\n        var eventType, touch, touchEvent;\n\n        log('touchchanged!');\n        event.changedTouches = [];\n        event.changedTouches.length = 1;\n        event.changedTouches[0] = event;\n        event.changedTouches[0].identifier = event.pointerId;\n\n        if (event.type === 'pointerup') {\n          eventType = 'touchend';\n        } else if (event.type === 'pointercancel') {\n          eventType = 'touchcancel';\n        } else if (event.type === 'pointerleave') {\n          eventType = 'touchleave';\n        }\n\n        touch = new touchesWrapper.Touch(\n          event.pointerId,\n          oldTarget,\n          event.screenX,\n          event.screenY,\n          event.clientX,\n          event.clientY,\n          event.pageX,\n          event.pageY\n        );\n\n        // This is a new touch event if it happened at a greater time than the last touch event.\n        // If it is a new touch event, clear out the changedTouches TouchList.\n        if (event.hwTimestamp > lastHwTimestamp) {\n          changedTouchesWrapper.clearTouches();\n        }\n\n        touchesWrapper.removeTouch(touch.identifier);\n        changedTouchesWrapper.addUpdateTouch(touch);\n        updateTargetTouches(touch.target, touchesWrapper.touchList);\n\n        event.type = eventType;\n        touchEvent = new CustomEvent(eventType, {\n          bubbles: true,\n          cancelable: true\n        });\n        touchEvent.touches = touchesWrapper.touchList;\n        touchEvent.changedTouches = changedTouchesWrapper.touchList;\n        touchEvent.targetTouches = targetTouchesWrapper.touchList;\n        touchEvent.type = eventType;\n\n        return touchEvent;\n      }\n\n      // An important difference between the MS pointer events and the W3C touch events\n      // is that for pointer events except for pointerdown, all target the element that the touch\n      // is over when the event is fired.\n      // The W3C touch events target the element where the touch originally started.\n      // Therefore, when these events are fired, we must make this change manually.\n      if (sourceEvent.type !== 'pointerdown') {\n        oldTouch = touchesWrapper.getTouch(sourceEvent.pointerId);\n        oldTarget = oldTouch.target;\n        sourceEvent.target = oldTarget;\n      }\n\n      if (\n        sourceEvent.type === 'pointerdown' ||\n        sourceEvent.type === 'pointermove'\n      ) {\n        evObj = touchHandler(sourceEvent);\n      } else {\n        evObj = touchChangedHandler(sourceEvent);\n      }\n\n      // PreventDefault\n      evObj.preventDefault = function() {\n        if (sourceEvent.preventDefault !== undefined) {\n          sourceEvent.preventDefault();\n        }\n      };\n\n      // Fire event\n      log('dispatching!');\n      sourceEvent.target.dispatchEvent(evObj);\n\n      lastHwTimestamp = event.hwTimestamp;\n    }\n\n    function generateTouchEventProxy(\n      name,\n      touchPoint,\n      target,\n      eventObject,\n      canBubble,\n      relatedTarget\n    ) {\n      generateTouchClonedEvent(\n        touchPoint,\n        name,\n        canBubble,\n        target,\n        relatedTarget\n      );\n    }\n\n    function registerOrUnregisterEvent(item, name, func, enable) {\n      log('registerOrUnregisterEvent');\n      if (item.__handJobjsRegisteredEvents === undefined) {\n        item.__handJobjsRegisteredEvents = [];\n      }\n\n      if (enable) {\n        if (item.__handJobjsRegisteredEvents[name] !== undefined) {\n          item.__handJobjsRegisteredEvents[name] += 1;\n          return;\n        }\n\n        item.__handJobjsRegisteredEvents[name] = 1;\n        log('adding event ' + name);\n        item.addEventListener(name, func, false);\n      } else {\n        if (item.__handJobjsRegisteredEvents.indexOf(name) !== -1) {\n          item.__handJobjsRegisteredEvents[name] -= 1;\n\n          if (item.__handJobjsRegisteredEvents[name] !== 0) {\n            return;\n          }\n        }\n        log('removing event');\n        item.removeEventListener(name, func);\n        item.__handJobjsRegisteredEvents[name] = 0;\n      }\n    }\n\n    function setTouchAware(item, eventName, enable) {\n      var eventGenerator, targetEvent;\n\n      function nameGenerator(name) {\n        return name;\n      } // easier than doing this right and replacing all the references\n\n      log('setTouchAware ' + enable + ' ' + eventName);\n      // Leaving tokens\n      if (!item.__handJobjsGlobalRegisteredEvents) {\n        item.__handJobjsGlobalRegisteredEvents = [];\n      }\n      if (enable) {\n        if (item.__handJobjsGlobalRegisteredEvents[eventName] !== undefined) {\n          item.__handJobjsGlobalRegisteredEvents[eventName] += 1;\n          return;\n        }\n        item.__handJobjsGlobalRegisteredEvents[eventName] = 1;\n\n        log(item.__handJobjsGlobalRegisteredEvents[eventName]);\n      } else {\n        if (item.__handJobjsGlobalRegisteredEvents[eventName] !== undefined) {\n          item.__handJobjsGlobalRegisteredEvents[eventName] -= 1;\n          if (item.__handJobjsGlobalRegisteredEvents[eventName] < 0) {\n            item.__handJobjsGlobalRegisteredEvents[eventName] = 0;\n          }\n        }\n      }\n\n      eventGenerator = generateTouchClonedEvent;\n\n      //switch (eventName) {\n      //    case \"touchenter\":\n      //      log(\"touchenter\");\n      //      break;\n      //    case \"touchleave\":\n      //      log(\"touchleave\");\n      targetEvent = nameGenerator(eventName);\n\n      if (item['on' + targetEvent.toLowerCase()] !== undefined) {\n        registerOrUnregisterEvent(\n          item,\n          targetEvent,\n          function(evt) {\n            eventGenerator(evt, eventName);\n          },\n          enable\n        );\n      }\n      //        break;\n      //}\n    }\n\n    // Intercept addEventListener calls by changing the prototype\n    function interceptAddEventListener(root) {\n      var current = root.prototype\n        ? root.prototype.addEventListener\n        : root.addEventListener;\n\n      function customAddEventListener(name, func, capture) {\n        log('customAddEventListener');\n        log(name);\n\n        if (supportedEventsNames.indexOf(name) !== -1) {\n          log('setting touch aware...');\n          setTouchAware(this, name, true);\n        }\n        current.call(this, name, func, capture);\n      }\n\n      log('intercepting add event listener!');\n      log(root);\n\n      if (root.prototype) {\n        root.prototype.addEventListener = customAddEventListener;\n      } else {\n        root.addEventListener = customAddEventListener;\n      }\n    }\n\n    function handleOtherEvent(eventObject, name) {\n      log('handle other event');\n      if (eventObject.preventManipulation) {\n        eventObject.preventManipulation();\n      }\n\n      // TODO: JSLint found that touchPoint here is an implied global!\n      generateTouchClonedEvent(touchPoint, name);\n    }\n\n    function removeTouchAware(item, eventName) {\n      // If item is already touch aware, do nothing\n      if (item.ontouchdown !== undefined) {\n        return;\n      }\n\n      // Chrome, Firefox\n      if (item.ontouchstart !== undefined) {\n        switch (eventName.toLowerCase()) {\n          case 'touchstart':\n            item.removeEventListener('pointerdown', function(evt) {\n              handleOtherEvent(evt, eventName);\n            });\n            break;\n          case 'touchmove':\n            item.removeEventListener('pointermove', function(evt) {\n              handleOtherEvent(evt, eventName);\n            });\n            break;\n          case 'touchend':\n            item.removeEventListener('pointerup', function(evt) {\n              handleOtherEvent(evt, eventName);\n            });\n            break;\n          case 'touchcancel':\n            item.removeEventListener('pointercancel', function(evt) {\n              handleOtherEvent(evt, eventName);\n            });\n            break;\n        }\n      }\n    }\n\n    // Intercept removeEventListener calls by changing the prototype\n    function interceptRemoveEventListener(root) {\n      var current = root.prototype\n        ? root.prototype.removeEventListener\n        : root.removeEventListener;\n\n      function customRemoveEventListener(name, func, capture) {\n        // Branch when a PointerXXX is used\n        if (supportedEventsNames.indexOf(name) !== -1) {\n          removeTouchAware(this, name);\n        }\n\n        current.call(this, name, func, capture);\n      }\n\n      if (root.prototype) {\n        root.prototype.removeEventListener = customRemoveEventListener;\n      } else {\n        root.removeEventListener = customRemoveEventListener;\n      }\n    }\n\n    function checkEventRegistration(node, eventName) {\n      log('checkEventRegistration');\n      return (\n        node.__handJobjsGlobalRegisteredEvents &&\n        node.__handJobjsGlobalRegisteredEvents[eventName]\n      );\n    }\n\n    function findEventRegisteredNode(node, eventName) {\n      log('findEventRegisteredNode');\n      while (node && !checkEventRegistration(node, eventName)) {\n        node = node.parentNode;\n      }\n      if (node) {\n        return node;\n      }\n      if (checkEventRegistration(window, eventName)) {\n        return window;\n      }\n    }\n\n    function generateTouchEventProxyIfRegistered(\n      eventName,\n      touchPoint,\n      target,\n      eventObject,\n      canBubble,\n      relatedTarget\n    ) {\n      // Check if user registered this event\n      log('generateTouchEventProxyIfRegistered');\n      if (findEventRegisteredNode(target, eventName)) {\n        generateTouchEventProxy(\n          eventName,\n          touchPoint,\n          target,\n          eventObject,\n          canBubble,\n          relatedTarget\n        );\n      }\n    }\n\n    function getDomUpperHierarchy(node) {\n      var nodes = [];\n      if (node) {\n        nodes.unshift(node);\n        while (node.parentNode) {\n          nodes.unshift(node.parentNode);\n          node = node.parentNode;\n        }\n      }\n      return nodes;\n    }\n\n    function getFirstCommonNode(node1, node2) {\n      var parents1 = getDomUpperHierarchy(node1),\n        parents2 = getDomUpperHierarchy(node2),\n        lastmatch = null;\n\n      while (parents1.length > 0 && parents1[0] === parents2.shift()) {\n        lastmatch = parents1.shift();\n      }\n      return lastmatch;\n    }\n\n    // generateProxy receives a node to dispatch the event\n    function dispatchPointerEnter(currentTarget, relatedTarget, generateProxy) {\n      log('dispatchPointerEnter');\n      var commonParent = getFirstCommonNode(currentTarget, relatedTarget),\n        node = currentTarget,\n        nodelist = [];\n\n      while (node && node !== commonParent) {\n        // target range: this to the direct child of parent relatedTarget\n        if (checkEventRegistration(node, 'touchenter')) {\n          // check if any parent node has pointerenter\n          nodelist.push(node);\n        }\n        node = node.parentNode;\n      }\n      while (nodelist.length > 0) {\n        generateProxy(nodelist.pop());\n      }\n    }\n\n    // generateProxy receives a node to dispatch the event\n    function dispatchPointerLeave(currentTarget, relatedTarget, generateProxy) {\n      log('dispatchPointerLeave');\n      var commonParent = getFirstCommonNode(currentTarget, relatedTarget),\n        node = currentTarget;\n      while (node && node !== commonParent) {\n        //target range: this to the direct child of parent relatedTarget\n        if (checkEventRegistration(node, 'touchleave')) {\n          // check if any parent node has pointerleave\n          generateProxy(node);\n        }\n        node = node.parentNode;\n      }\n    }\n\n    function log(s) {\n      if (logToConsole) {\n        console.log(s.toString());\n      }\n    }\n\n    CustomEvent.prototype = window.Event.prototype;\n\n    if (typeof window.ontouchstart === 'object') {\n      return;\n    }\n\n    if (\n      userAgent.match(/iPad/i) ||\n      userAgent.match(/iPhone/i) ||\n      userAgent.match(/iPod/i) ||\n      userAgent.match(/Android/i) ||\n      (userAgent.match(/MSIE/i) && !userAgent.match(/Touch/i))\n    ) {\n      return;\n    }\n\n    // Add CSS to disable MS IE default scrolling functionality.\n    (function() {\n      var css = 'html { -ms-touch-action: none; }',\n        head = document.head || document.getElementsByTagName('head')[0],\n        style = document.createElement('style');\n\n      style.type = 'text/css';\n      if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n      } else {\n        style.appendChild(document.createTextNode(css));\n      }\n\n      head.appendChild(style);\n    })();\n\n    touchesWrapper = new TouchListWrapper();\n    changedTouchesWrapper = new TouchListWrapper();\n    targetTouchesWrapper = new TouchListWrapper();\n\n    window.CustomEvent = CustomEvent;\n\n    // Hooks\n    interceptAddEventListener(window);\n    interceptAddEventListener(window.HTMLElement || window.Element);\n    interceptAddEventListener(document);\n    interceptAddEventListener(HTMLBodyElement);\n    interceptAddEventListener(HTMLDivElement);\n    interceptAddEventListener(HTMLImageElement);\n    interceptAddEventListener(HTMLUListElement);\n    interceptAddEventListener(HTMLAnchorElement);\n    interceptAddEventListener(HTMLLIElement);\n    interceptAddEventListener(HTMLTableElement);\n    if (window.HTMLSpanElement) {\n      interceptAddEventListener(HTMLSpanElement);\n    }\n    if (window.HTMLCanvasElement) {\n      interceptAddEventListener(HTMLCanvasElement);\n    }\n    if (window.SVGElement) {\n      interceptAddEventListener(SVGElement);\n    }\n\n    interceptRemoveEventListener(window);\n    interceptRemoveEventListener(window.HTMLElement || window.Element);\n    interceptRemoveEventListener(document);\n    interceptRemoveEventListener(HTMLBodyElement);\n    interceptRemoveEventListener(HTMLDivElement);\n    interceptRemoveEventListener(HTMLImageElement);\n    interceptRemoveEventListener(HTMLUListElement);\n    interceptRemoveEventListener(HTMLAnchorElement);\n    interceptRemoveEventListener(HTMLLIElement);\n    interceptRemoveEventListener(HTMLTableElement);\n    if (window.HTMLSpanElement) {\n      interceptRemoveEventListener(HTMLSpanElement);\n    }\n    if (window.HTMLCanvasElement) {\n      interceptRemoveEventListener(HTMLCanvasElement);\n    }\n    if (window.SVGElement) {\n      interceptRemoveEventListener(SVGElement);\n    }\n\n    (function() {\n      // Returns true if and only if the event should be ignored.\n      function ignorePointerEvent(event) {\n        // Don't interpret mouse pointers as touches\n        if (event.pointerType === 'mouse') {\n          return true;\n        }\n        // Don't interpret pointerdown events on the scrollbars as touch events.\n        // It appears to be the case that when the event is on the scrollbar in IE,\n        // event.x === 0 and event.y === 0\n        if (event.type === 'pointerdown' && event.x === 0 && event.y === 0) {\n          return true;\n        }\n        // A user reported that when the input type is 'pen', the pointermove event fires with a pressure of 0\n        // before the pen touches the screen.  We want to ignore this.\n        if (\n          event.pointerType === 'pen' &&\n          event.pressure === 0 &&\n          event.type === 'pointermove'\n        ) {\n          return true;\n        }\n        return false;\n      }\n\n      // Handling move on window to detect pointerleave/out/over\n      window.addEventListener('pointerdown', function(eventObject) {\n        log('pointerdownfired');\n        var touchPoint = eventObject;\n\n        if (ignorePointerEvent(eventObject)) {\n          return;\n        }\n\n        previousTargets[touchPoint.identifier] = touchPoint.target;\n        generateTouchEventProxyIfRegistered(\n          'touchenter',\n          touchPoint,\n          touchPoint.target,\n          eventObject,\n          true\n        );\n\n        // pointerenter should not be bubbled\n        dispatchPointerEnter(touchPoint.target, null, function(targetNode) {\n          generateTouchEventProxy(\n            'touchenter',\n            touchPoint,\n            targetNode,\n            eventObject,\n            false\n          );\n        });\n\n        generateTouchEventProxyIfRegistered(\n          'touchstart',\n          touchPoint,\n          touchPoint.target,\n          eventObject,\n          true\n        );\n      });\n\n      window.addEventListener('pointerup', function(eventObject) {\n        var touchPoint = eventObject,\n          currentTarget = previousTargets[touchPoint.identifier];\n\n        log('pointer up fired');\n\n        if (ignorePointerEvent(eventObject)) {\n          return;\n        }\n\n        generateTouchEventProxyIfRegistered(\n          'touchend',\n          touchPoint,\n          currentTarget,\n          eventObject,\n          true\n        );\n        generateTouchEventProxyIfRegistered(\n          'touchleave',\n          touchPoint,\n          currentTarget,\n          eventObject,\n          true\n        );\n\n        //pointerleave should not be bubbled\n        dispatchPointerLeave(currentTarget, null, function(targetNode) {\n          generateTouchEventProxy(\n            'touchleave',\n            touchPoint,\n            targetNode,\n            eventObject,\n            false\n          );\n        });\n      });\n\n      window.addEventListener('pointermove', function(eventObject) {\n        var touchPoint = eventObject,\n          currentTarget = previousTargets[touchPoint.identifier];\n\n        log('pointer move fired');\n\n        if (ignorePointerEvent(eventObject)) {\n          return;\n        }\n\n        log('x: ' + eventObject.screenX + ', y: ' + eventObject.screenY);\n\n        // pointermove fires over and over when a touch-point stays stationary.\n        // This is at odds with the other browsers that implement the W3C standard touch events\n        // which fire touchmove only when the touch-point actually moves.\n        // Therefore, return without doing anything if the pointermove event fired for a touch\n        // that hasn't moved.\n        if (\n          touchesWrapper.containsTouchAt(eventObject.screenX, eventObject.screenY)\n        ) {\n          return;\n        }\n\n        // If force preventDefault\n        if (currentTarget && checkPreventDefault(currentTarget) === true) {\n          eventObject.preventDefault();\n        }\n\n        generateTouchEventProxyIfRegistered(\n          'touchmove',\n          touchPoint,\n          currentTarget,\n          eventObject,\n          true\n        );\n      });\n    })();\n  })();\n}\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "define", "amd", "window", "installedModules", "__webpack_require__", "moduleId", "i", "l", "modules", "call", "m", "c", "d", "name", "getter", "o", "Object", "defineProperty", "enumerable", "get", "r", "Symbol", "toStringTag", "value", "t", "mode", "__esModule", "ns", "create", "key", "bind", "n", "object", "property", "prototype", "hasOwnProperty", "p", "s", "e", "editor", "_touchpolyfill2", "default", "_DragDropTouch2", "DragDropTouch", "DragDropTouch_1", "DataTransfer", "this", "_dropEffect", "_effectAllowed", "_data", "set", "configurable", "keys", "clearData", "type", "getData", "setData", "setDragImage", "img", "offsetX", "offsetY", "ddt", "_instance", "_imgCustom", "_imgOffset", "x", "y", "_lastClick", "supportsPassive", "document", "addEventListener", "passive", "ts", "_touchstart", "tm", "_touchmove", "te", "_touchend", "opt", "capture", "getInstance", "_this", "_shouldHandle", "Date", "now", "_DBLCLICK", "_dispatchEvent", "target", "preventDefault", "_reset", "src", "_closestDraggable", "_dragSource", "_ptDown", "_getPoint", "_lastTouch", "setTimeout", "_img", "_CTXMENU", "_getTarget", "_getDelta", "_THRESHOLD", "_createImage", "_lastTarget", "_moveImage", "_destroyImage", "indexOf", "defaultPrevented", "touches", "length", "_dataTransfer", "page", "pageX", "clientX", "pageY", "clientY", "Math", "abs", "pt", "el", "elementFromPoint", "nodeName", "iframeDocument", "contentWindow", "iframeAbsoluteOffset", "offsetLeft", "offsetTop", "offsetParent", "getComputedStyle", "pointerEvents", "parentElement", "cloneNode", "_copyStyle", "style", "top", "left", "rc", "getBoundingClientRect", "opacity", "_OPACITY", "toString", "body", "appendChild", "removeChild", "requestAnimationFrame", "position", "zIndex", "round", "_copyProps", "dst", "props", "_rmvAtts", "forEach", "att", "removeAttribute", "HTMLCanvasElement", "cSrc", "cDst", "width", "height", "getContext", "drawImage", "cs", "children", "evt", "createEvent", "initEvent", "button", "which", "buttons", "_kbdProps", "_ptProps", "dataTransfer", "dispatchEvent", "hasAttribute", "draggable", "split", "touchesWrapper", "changedTouchesWrapper", "targetTouchesWrapper", "lastHwTimestamp", "logToConsole", "userAgent", "navigator", "supportedEventsNames", "previousTargets", "TouchListWrapper", "touchList", "Touch", "identifier", "screenX", "screenY", "getTouch", "addUpdateTouch", "touch", "push", "removeTouch", "splice", "clearTouches", "pop", "containsTouchAt", "touchesAreAtSameSpot", "touch0", "touch1", "CustomEvent", "event", "params", "bubbles", "cancelable", "detail", "undefined", "initCustomEvent", "generateTouchClonedEvent", "sourceEvent", "newName", "canBubble", "relatedTarget", "evObj", "oldTouch", "oldTarget", "updateTargetTouches", "thisTouchTarget", "touchesTouchList", "isSameNode", "pointerId", "eventType", "touchEvent", "log", "Error", "hwTimestamp", "changedTouchList", "changedTouch", "matchingTouch", "changedTouches", "targetTouches", "generateTouchEventProxy", "touchPoint", "eventObject", "setTouchAware", "item", "eventName", "enable", "eventGenerator", "targetEvent", "__handJobjsGlobalRegisteredEvents", "toLowerCase", "func", "__handJobjsRegisteredEvents", "removeEventListener", "interceptAddEventListener", "current", "customAddEventListener", "handleOtherEvent", "preventManipulation", "interceptRemoveEventListener", "customRemoveEventListener", "ontouchdown", "ontouchstart", "checkEventRegistration", "node", "generateTouchEventProxyIfRegistered", "parentNode", "getDomUpperHierarchy", "nodes", "unshift", "getFirstCommonNode", "node1", "node2", "parents1", "parents2", "lastmatch", "shift", "console", "Event", "_typeof", "match", "css", "head", "getElementsByTagName", "createElement", "styleSheet", "cssText", "createTextNode", "HTMLElement", "Element", "HTMLBodyElement", "HTMLDivElement", "HTMLImageElement", "HTMLUListElement", "HTMLAnchorElement", "HTMLLIElement", "HTMLTableElement", "HTMLSpanElement", "SVGElement", "ignorePointerEvent", "pointerType", "pressure", "currentTarget", "generateProxy", "commonParent", "nodelist", "targetNode", "handJobjs_forcePreventDefault"]
}
